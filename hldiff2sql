#!/usr/bin/env python3

import argparse
import sys
import csv


def readrows(file):
    r = csv.reader(file)
    header = next(r)
    return list(r), header


def gen_insert_sql(table, cols):
    return 'insert into {table} ({cols}) values ({values})'.format(
        table=table,
        cols=', '.join(cols),
        values=', '.join(['?'] * len(cols))
    )


def gen_insert_chunks(table, diffrows, cols):
    inserted_rows = [
        row[1:]
        for row in filter(lambda r: r[0] == '+++', diffrows)
    ]
    if inserted_rows:
        return [
            [[gen_insert_sql(table, cols)]] +
            [cols] + 
            inserted_rows
        ]
    return []


def gen_delete_sql(table, cols):
    return 'delete from {table} where {filters}'.format(
        table=table,
        filters=' and '.join([c + ' = ?' for c in cols])
    )


def gen_delete_chunks(table, diffrows, cols):
    deleted_rows = [
        row[1:]
        for row in filter(lambda r: r[0] == '---', diffrows)
    ]
    if deleted_rows:
        return [
            [[gen_delete_sql(table, cols)]] +
            [cols] +
            deleted_rows
        ]
    return []


def gen_update_sql(table, cols, updated_cols):
    return 'update {table} set {setters} where {filters}'.format(
        table=table,
        setters=', '.join([c + ' = ?' for c in updated_cols]),
        filters=' and '.join([c + ' = ?' for c in cols])
    )


def get_update_items(updated_rows):
    items = []
    for row in updated_rows:
        tag = row[0]
        updated_cols = []
        new_vals = []
        orig_row = []
        for col, val in enumerate(row[1:]):
            if tag in val:
                updated_cols.append(col)
                old, new = val.split(tag)
                orig_row.append(old)
                new_vals.append(new)
            else:
                orig_row.append(val)

        items.append((updated_cols, new_vals, orig_row))
        
    return items


def gen_update_chunks(table, diffrows, cols):
    updated_rows = filter(lambda r: r[0].endswith('->'), diffrows)
    items = get_update_items(updated_rows)
    updates = []
    for updated_col_indices, new_vals, orig_row in items:
        updated_cols = [cols[i] for i in updated_col_indices]
        updates.append([
            [gen_update_sql(table, cols, updated_cols)],
            updated_cols + cols,
            new_vals + orig_row
        ])
    return updates


def insert_between(value, lst):
    """Return list where value is inserted between every two items of lst."""
    return sum([[x, value] for x in lst[:-1]], []) + lst[-1:]


def writerows(file, rows):
    csv.writer(file, delimiter='\t').writerows(rows)


def main(table):
    diffrows, cols = readrows(sys.stdin)
    cols = cols[1:] # remove action column from header

    chunks = (
        gen_insert_chunks(table, diffrows, cols) +
        gen_delete_chunks(table, diffrows, cols) +
        gen_update_chunks(table, diffrows, cols)
    )
    # insert empty rows between chunks, they will be output as empty
    # line separators
    chunks = insert_between([[]], chunks)
    # concatenate chunks to produce list of rows
    out_rows = sum(chunks, [])
    writerows(sys.stdout, out_rows)    


def setup():
    # Redefine stdin to not translate newlines. Otherwise when reading
    # csv field containing \r\n on Windows it gets translated to \n,
    # i.e. data gets corrupted. Always use utf-8.
    sys.stdin = open(
        sys.stdin.fileno(),
        mode=sys.stdin.mode,
        encoding='utf-8',
        errors=sys.stdin.errors,
        newline='',
        closefd=False
    )
    # Redefine stdout to not translate newlines. csv module (as per
    # rfc 4180) writes \r\n. Otherwise when on Windows, \n is
    # translated to \r\n, so original \r\n becomes \r\r\n. Always use
    # utf-8.
    sys.stdout = open(
        sys.stdout.fileno(),
        mode=sys.stdout.mode,
        encoding='utf-8',
        errors=sys.stdout.errors,
        newline='',
        closefd=False
    )


def parse_args():
    p = argparse.ArgumentParser(
        description='Convert highlighter diff to sql instructions to patch the table'
    )
    p.add_argument(
        'table',
        help='target table'
    )
    return p.parse_args()


if __name__ == '__main__':
    args = parse_args()
    setup()
    main(args.table)
